{"version":3,"file":"podtable.js","sources":["../src/podtable.js","../src/utils.js"],"sourcesContent":["import { watch, getTable, detachRows } from './utils';\n\nfunction Podtable(tableEl, config = {}) {\n    /**\n     * default config options\n     * @type Object\n     */\n    let defaultOptions = {\n        keepCell: [],\n        priority: [],\n        method: null,\n        rowGroup: false,\n    };\n\n    /**\n     * Podtable instance\n     * @return object\n     */\n    let _this = {};\n\n    /**\n     * config options\n     */\n    let options = Object.assign({}, defaultOptions, config);\n\n    /**\n     * The associated table that podtable will render\n     * @returns HTMLTableElement\n     */\n    const table = getTable(tableEl);\n\n    /**\n     * This is the squishitude determinant row\n     * @type HTMLTableRowElement\n     */\n    let targetRow;\n\n    /**\n     * A wrapper for the render table\n     * @returns HTMLElement\n     */\n    let tableContainer;\n\n    /**\n     * Perform an health check on the passed table\n     * @returns void\n     */\n    healthCheck(table);\n\n    /**\n     * Cache container width after health check passed\n     */\n    let oldTableContainerWidth = tableContainer.clientWidth;\n\n    /**\n     * This is store for currently hidden cells\n     * @type Array\n     */\n    let hiddenCells = [];\n\n    /**\n     * Constant index of cells generated from target row\n     * @type Array\n     */\n    let constIndex = [];\n\n    /**\n     * @type object\n     */\n    let state = { current: -1 };\n\n    /**\n     * Process the config options passed\n     * @returns void\n     */\n    processConfig();\n\n    /**\n     * Attach event listeners for control toggle\n     * @returns void\n     */\n    setToggleCell(table);\n\n    /**\n     * Resize event method\n     */\n    _this.watchResize = false;\n\n    /**\n     * Resize event method\n     */\n    _this.nativeResize = false;\n\n    /**\n     * observer event method\n     */\n    _this.observer = false;\n\n    /**\n     * Renders the table for the first instance\n     * @returns void\n     */\n    render();\n\n    /**\n     * Starts a mutation observer\n     * @returns void\n     */\n    watchMutation(table);\n\n    /**\n     * Set rendering target row\n     * @param {HTMLTableElement} table\n     */\n    function setTargetRow(table) {\n        targetRow = table.tHead.rows[0];\n    }\n\n    /**\n     * set the wrapper for podtable\n     */\n    function setWrapper() {\n        tableContainer = document.createElement('div');\n        tableContainer.setAttribute('id', 'podtable-container');\n        table.parentNode.insertBefore(tableContainer, table);\n        tableContainer.appendChild(table);\n    }\n\n    /**\n     * Perform health check and if it fail will throw an error\n     * @param {HTMLTableElement} table\n     */\n    function healthCheck(table) {\n        if (\n            !(table instanceof HTMLTableElement) ||\n            table == null ||\n            table.tHead == null\n        ) {\n            throw new Error('Invalid HTMLTableElement');\n        }\n\n        if (\n            table.tHead.rows.length <= 0 ||\n            table.tHead.rows[0].cells.length < 0\n        ) {\n            throw new Error('Invalid tHead HTMLTableRowElement');\n        }\n\n        setTargetRow(table);\n        setWrapper();\n    }\n\n    /**\n     * Sets the control cells CSS clasess\n     * @param {String} tableEl\n     */\n    function setToggleCell(table) {\n        for (let row of table.rows) {\n            if (row.parentElement.tagName.toUpperCase() == 'TBODY') {\n                if (!row.hasAttribute('data-ptr-ignore')) {\n                    row.lastElementChild.classList.add('toggle');\n                }\n            }\n\n            if (row.parentElement.tagName.toUpperCase() == 'THEAD') {\n                row.lastElementChild.classList.add('main-toggle');\n            }\n        }\n    }\n\n    /**\n     * Set cell hidden priority from the right\n     * Set indexes of cells to keep\n     */\n    function processConfig() {\n        let tempConst = [];\n\n        for (let ci = 0; ci < targetRow.cells.length; ci++) {\n            tempConst.push(ci);\n        }\n\n        if (Array.isArray(options.priority) && options.priority.length > 0) {\n            constIndex = Array.from(\n                new Set(options.priority.concat(tempConst.reverse()))\n            );\n        } else {\n            constIndex = tempConst.reverse();\n        }\n\n        if (!Array.isArray(options.keepCell)) {\n            throw TypeError('keepCell is not an array');\n        } else {\n            options.keepCell.push(0, tempConst.length - 1);\n        }\n    }\n\n    /**\n     * Create HTMLTableRowElement & append cell column data\n     * @param {HTMLCollection} cells\n     * @returns HTMLTableRowElement\n     */\n    function childRow(cells) {\n        let tr = document.createElement('tr');\n        let gridTD = document.createElement('td');\n        let gridRow = document.createElement('div');\n\n        gridTD.colSpan = constIndex.length;\n        gridRow.classList.add('child-grid-row');\n        tr.classList.add('child');\n\n        for (let i = 0; i < cells.length; i++) {\n            gridRow.append(cells[i]);\n        }\n\n        gridTD.append(gridRow);\n        tr.append(gridTD);\n\n        return tr;\n    }\n\n    /**\n     * Create HTMLElement to append to child row\n     * @param {HTMLTableCellElement} el\n     * @returns HTMLElement\n     */\n    function gridCol(el) {\n        let gridCol = document.createElement('div');\n        gridCol.classList.add('child-grid-col');\n\n        let dataColName = document.createElement('div');\n        let dataColDesc = document.createElement('div');\n        dataColName.innerHTML =\n            table.tHead.rows[0].cells[el.cellIndex].innerHTML;\n        dataColDesc.innerHTML = el.innerHTML;\n\n        gridCol.append(dataColName);\n        gridCol.append(dataColDesc);\n\n        return gridCol;\n    }\n\n    /**\n     * Toggle single child row and calculate hidden element for the row\n     * @param {event} e\n     */\n    function toggle(e) {\n        if (hiddenCells.length <= 0) {\n            return;\n        }\n\n        let parent = e.currentTarget.parentElement;\n\n        if (parent.classList.contains('has-child')) {\n            parent.classList.remove('has-child');\n            parent.nextElementSibling.remove();\n        } else {\n            parent.classList.add('has-child');\n            let isHidden = [];\n            for (let i = 0; i < parent.cells.length; i++) {\n                if (parent.cells[i].classList.contains('hidden')) {\n                    isHidden.push(gridCol(parent.cells[i]));\n                }\n            }\n\n            parent.parentNode.insertBefore(\n                childRow(isHidden),\n                parent.nextSibling\n            );\n        }\n    }\n\n    /**\n     * Handles toggle all child rows event by checking which rows\n     * has child to close and which rows has no child to open\n     * @param {event} e\n     */\n    function toggleAll(e) {\n        if (hiddenCells.length <= 0) {\n            return;\n        }\n\n        let toggleEls = document.querySelectorAll('.toggle');\n        let toggler = e.currentTarget;\n\n        if (toggler.classList.contains('expanded')) {\n            for (let i = 0; i < toggleEls.length; i++) {\n                let togsParent = toggleEls[i].parentElement;\n                if (togsParent.classList.contains('has-child')) {\n                    toggleEls[i].click();\n                }\n            }\n\n            toggler.classList.remove('expanded');\n        } else {\n            for (let i = 0; i < toggleEls.length; i++) {\n                let togsParent = toggleEls[i].parentElement;\n                if (!togsParent.classList.contains('has-child')) {\n                    toggleEls[i].click();\n                }\n            }\n\n            toggler.classList.add('expanded');\n        }\n    }\n\n    /**\n     * Adds click Event listener to rows with css class of\n     * toggle and main-toggle so as to toggle child rows\n     * @return void\n     */\n    function addToggleListener() {\n        let togElements = document.querySelectorAll('.toggle');\n        for (let i = 0; i < togElements.length; i++) {\n            togElements[i].addEventListener('click', toggle);\n        }\n\n        let mainToggle = document.querySelector('.main-toggle');\n        mainToggle.addEventListener('click', toggleAll);\n    }\n\n    /**\n     * Run a try catch on a callback to avoid errors\n     * @param {*} callback\n     */\n    function rescue(callback) {\n        try {\n            return callback();\n        } catch (error) {}\n    }\n\n    /**\n     * Remove control toggle listener on rows\n     * @return object\n     */\n    function removeToggleListener() {\n        let togElements = document.querySelectorAll('.toggle');\n        for (let i = 0; i < togElements.length; i++) {\n            rescue(() => togElements[i].removeEventListener('click', toggle));\n        }\n\n        let mainToggle = document.querySelector('.main-toggle');\n        rescue(() => mainToggle.removeEventListener('click', toggleAll));\n    }\n\n    /**\n     * Check if there are hidden elements ands determine when to show\n     * child row toggle button and also clean up unused css class.\n     */\n    function doTogglerScreen() {\n        if (hiddenCells.length > 0) {\n            table.classList.add('show-toggle');\n        } else {\n            document.querySelectorAll('.has-child').forEach((el) => {\n                el.classList.remove('has-child');\n            });\n\n            table.classList.remove('show-toggle');\n            table.tHead.rows[0].cells[\n                table.tHead.rows[0].cells.length - 1\n            ].classList.remove('expanded');\n        }\n    }\n\n    /**\n     * Check for open child rows to enable reactivity as window resizes\n     * then apply changes, item are remove and added every time window resize\n     * and its like this so as to get an updated data from the cells\n     * child row are redrawn on each control toggle.\n     */\n    function childRowListener() {\n        let childRows = document.querySelectorAll('tr.child');\n\n        if (childRows.length > 0) {\n            let parentRows = [];\n\n            for (let row of childRows) {\n                parentRows.push(row.previousElementSibling);\n            }\n\n            // Iterate from parents elements down to child elements\n            for (let p = 0; p < parentRows.length; p++) {\n                let isHidden = [];\n\n                for (let cell of parentRows[p].cells) {\n                    if (cell.classList.contains('hidden')) {\n                        isHidden.push(gridCol(cell));\n                    }\n                }\n\n                // we will remove the existing child row and put another one with new data\n                // we also check if the hidden cells length > 0 before inserting a new child row\n                // so as to avoid empty child rows and orphaned child rows\n                parentRows[p].nextElementSibling.remove();\n\n                if (hiddenCells.length > 0) {\n                    parentRows[p].after(childRow(isHidden));\n                }\n\n                doTogglerScreen();\n            }\n        }\n    }\n\n    /**\n     * Hide cells that falls into maximum squishitude\n     * Dispatch event for the current hidden cells index\n     * @param {Number} index\n     */\n    function hideMain(index, pt = table) {\n        hiddenCells.push(index);\n\n        for (let row of pt.rows) {\n            if (\n                !row.classList.contains('child') &&\n                !row.hasAttribute('data-ptr-ignore')\n            ) {\n                row.cells[index].classList.add('hidden');\n            }\n        }\n\n        eventDispatch(index);\n    }\n\n    /**\n     * Here we remove the hidden class and flush the hidden cells\n     * array so as to restart procedure for the current viewport.\n     */\n    function flush() {\n        for (let i = 0; i < hiddenCells.length; i++) {\n            for (let row of table.rows) {\n                if (\n                    !row.classList.contains('child') &&\n                    !row.hasAttribute('data-ptr-ignore')\n                ) {\n                    row.cells[hiddenCells[i]].classList.remove('hidden');\n                }\n            }\n        }\n\n        hiddenCells = [];\n    }\n\n    /**\n     * Recalculate Cells thats needs to be hidden after flushing\n     */\n    function recalc() {\n        flush();\n\n        for (let i = 0; i < constIndex.length; i++) {\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\n                if (!hiddenCells.includes(constIndex[i])) {\n                    if (!options.keepCell.includes(constIndex[i])) {\n                        hideMain(constIndex[i]);\n                        childRowListener();\n                    }\n                }\n            }\n        }\n\n        doTogglerScreen();\n    }\n\n    /**\n     * This method recalculate which cells to hide or show and dispatch\n     * event with negative index to indicate there are no hiddenCells\n     */\n    function resize() {\n        recalc();\n\n        if (hiddenCells.length <= 0) {\n            eventDispatch(-1);\n            childRowListener();\n        }\n    }\n\n    /**\n     * On mounted calculate cells which  can fit into the current\n     * maximum squishitude: apply visibility, attach listeners.\n     */\n    function mount() {\n        hiddenCells = [];\n        let ilength = constIndex.length;\n\n        for (let i = 0; i < ilength; i++) {\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\n                if (!hiddenCells.includes(constIndex[i])) {\n                    if (!options.keepCell.includes(constIndex[i])) {\n                        hideMain(constIndex[i]);\n                    }\n                }\n            }\n        }\n        doTogglerScreen();\n    }\n\n    /**\n     * This is the resize counterpart for window resize event\n     * or element watcher event\n     * @see resize\n     */\n    function observeResize() {\n        recalc();\n        if (hiddenCells.length <= 0) {\n            eventDispatch(-1);\n            childRowListener();\n        }\n    }\n\n    /**\n     * Handles resize listener\n     * @returns boolean|ResizeObserver\n     */\n    function observed() {\n        try {\n            _this.nativeResize = new ResizeObserver((entries) => {\n                if (entries[0].target.clientWidth !== oldTableContainerWidth) {\n                    observeResize();\n                }\n\n                oldTableContainerWidth = entries[0].target.clientWidth;\n            });\n\n            _this.nativeResize.observe(tableContainer);\n            return true;\n        } catch (err) {\n            return false;\n        }\n    }\n\n    /**\n     * Starts an observer at podtable instance and\n     * attach necessary listeners\n     */\n    function render() {\n        mount();\n        addToggleListener();\n\n        if (!observed()) {\n            try {\n                _this.watchResize = watch(tableContainer, resize);\n                _this.watchResize.start();\n            } catch (err) {\n                window.addEventListener('resize', resize);\n            }\n        }\n    }\n\n    /**\n     * Revert all events made to the DOM\n     */\n    function destroy() {\n        window.removeEventListener('resize', resize);\n        flush();\n\n        detachRows(table, tableContainer, _this);\n        removeToggleListener();\n    }\n\n    /**\n     * Revert any alteration to the table in the DOM\n     * and detach events\n     * @returns void\n     */\n    state.destroy = () => destroy();\n\n    /**\n     * Handles childList mutations by re-attaching attributes,\n     * events and dispatching events\n     * @param {HTMLTableElement} table\n     */\n    function watchMutation(table) {\n        function resetRow(node) {\n            if (!node.hasAttribute('data-ptr-ignore')) {\n                node.lastElementChild.classList.add('toggle');\n                node.lastElementChild.addEventListener('click', (e) =>\n                    toggle(e)\n                );\n            }\n        }\n\n        const callback = (mutations) => {\n            for (const mutation of mutations) {\n                if (\n                    mutation.type == 'childList' &&\n                    mutation.addedNodes.length == 1\n                ) {\n                    if (\n                        mutation.addedNodes[0].tagName.toUpperCase() == 'TBODY'\n                    ) {\n                        for (let node of mutation.addedNodes[0].children) {\n                            resetRow(node);\n                            shouldPing();\n                        }\n                    }\n\n                    if (\n                        mutation.addedNodes[0].tagName.toUpperCase() == 'TR' &&\n                        !mutation.addedNodes[0].classList.contains('child')\n                    ) {\n                        resetRow(mutation.addedNodes[0]);\n                        shouldPing();\n                    }\n                } else if (\n                    mutation.type == 'childList' &&\n                    mutation.removedNodes.length == 1\n                ) {\n                    if (\n                        mutation.removedNodes[0].tagName.toUpperCase() ==\n                            'TR' &&\n                        !mutation.removedNodes[0].classList.contains('child') &&\n                        mutation.removedNodes[0].classList.contains('has-child')\n                    ) {\n                        mutation.nextSibling.remove();\n                    }\n                }\n            }\n\n            setTargetRow(table);\n            flush();\n            mount();\n        };\n\n        let observable = options.rowGroup ? table : table.tBodies[0];\n        _this.observer = new MutationObserver(callback);\n        _this.observer.observe(observable, { childList: true });\n    }\n\n    /**\n     * Dispatch event for the current hidden cell index\n     * @param {Number} index\n     */\n    function eventDispatch(index) {\n        state.current = index;\n\n        if (options.method) {\n            shouldPing();\n        }\n    }\n\n    /**\n     * Dispatchs event\n     */\n    function shouldPing() {\n        if (options.method) {\n            try {\n                options.method(state);\n            } catch (err) {\n                console.error(err);\n            }\n        }\n    }\n\n    return state;\n}\n\nexport default Podtable;\n","export function watch(element, fn) {\n    let _this = {}\n    let obj = document.createElement('object')\n\n    /**\n     * Event listener to the docs object\n     */\n    function resizeEvent () {\n        this.contentDocument.defaultView.addEventListener('resize', fn)\n    }\n\n    /**\n     * Attach event listener to object\n     */\n    _this.start = () => {\n        obj.classList.add('pt-object')\n        obj.type = 'text/html'\n        obj.data = 'about:blank'\n        obj.onload = resizeEvent\n        element.appendChild(obj)\n    }\n\n    /**\n     * dettach event listener and remove object\n     */\n    _this.stop = () => {\n        obj.contentDocument.defaultView.removeEventListener('resize', fn)\n        element.removeChild(obj)\n    }\n\n    return _this\n}\n\n/**\n * Returns the target table element\n * @param {String|HTMLTableElement} tableEl \n * @returns HTMLTableElement\n */\nexport function getTable(tableEl) {\n    if (typeof tableEl === 'string' || tableEl instanceof String) {\n        return document.querySelector(tableEl)\n    } else {\n        return tableEl\n    }\n}\n\n/**\n * Detach child rows from the dom and remove classes\n * @param { HTMLTableElement }\n */\nexport function detachRows(table, container, _this) {\n    _this.observer.disconnect()\n\n    if (typeof _this.nativeResize !== undefined && _this.nativeResize !== false)\n        _this.nativeResize.disconnect()\n    \n    if (typeof _this.watchResize !== undefined && _this.watchResize !== false)\n        _this.watchResize.stop()\n\n    let parentRows = table.querySelectorAll('tr.has-child')\n\n    for (let row of parentRows) {\n        row.classList.remove('has-child')\n        if (row.nextElementSibling.classList.contains('child')) {\n            row.nextElementSibling.remove()\n        }\n    }\n\n    table.classList.remove('show-toggle')\n    container.replaceWith(...container.childNodes)\n}"],"names":["tableEl","config","targetRow","tableContainer","_this","options","Object","assign","keepCell","priority","method","rowGroup","table","String","document","querySelector","getTable","HTMLTableElement","tHead","Error","rows","length","cells","setTargetRow","setWrapper","healthCheck","oldTableContainerWidth","clientWidth","hiddenCells","constIndex","state","current","createElement","setAttribute","parentNode","insertBefore","appendChild","childRow","tr","gridTD","gridRow","colSpan","classList","add","i","append","gridCol","el","dataColName","dataColDesc","innerHTML","cellIndex","toggle","e","parent","currentTarget","parentElement","contains","remove","nextElementSibling","isHidden","push","nextSibling","toggleAll","toggleEls","querySelectorAll","toggler","click","rescue","callback","error","doTogglerScreen","forEach","childRowListener","childRows","_step2","parentRows","_iterator2","_createForOfIteratorHelperLoose","done","value","previousElementSibling","p","_step3","_iterator3","cell","after","hideMain","index","pt","_step4","_iterator4","row","hasAttribute","eventDispatch","flush","_iterator5","_step5","recalc","includes","resize","mount","ilength","shouldPing","err","console","tempConst","ci","Array","isArray","from","Set","concat","reverse","TypeError","processConfig","_iterator","_step","tagName","toUpperCase","lastElementChild","setToggleCell","watchResize","nativeResize","observer","togElements","addEventListener","addToggleListener","ResizeObserver","entries","target","observe","observed","element","fn","obj","resizeEvent","this","contentDocument","defaultView","start","type","data","onload","stop","removeEventListener","removeChild","watch","window","render","resetRow","node","observable","tBodies","MutationObserver","mutations","_step6","_iterator6","mutation","addedNodes","_step7","_iterator7","children","removedNodes","childList","watchMutation","destroy","container","disconnect","undefined","replaceWith","apply","childNodes","detachRows","_loop","mainToggle","removeToggleListener"],"mappings":"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"}