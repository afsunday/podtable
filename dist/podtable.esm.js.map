{"version":3,"file":"podtable.esm.js","sources":["../src/podtable.js","../src/utils.js"],"sourcesContent":["import { watch, getTable, detachRows } from './utils'\n\nfunction Podtable(tableEl, config = {}) {\n    /**\n     * default config options\n     * @type Object\n     */\n    let defaultOptions = {\n        keepCell: [],\n        priority: [],\n        method: null,\n        rowGroup: false\n    }\n\n    /**\n     * Podtable instance\n     * @return object\n     */\n    let _this = {}\n\n    /**\n     * config options\n     */\n    let options = Object.assign({}, defaultOptions, config)\n\n    /**\n     * The associated table that podtable will render\n     * @returns HTMLTableElement\n     */\n    const table = getTable(tableEl)\n\n    /**\n     * This is the squishitude determinant row\n     * @type HTMLTableRowElement\n     */\n    let targetRow\n\n    /**\n     * A wrapper for the render table\n     * @returns HTMLElement\n     */\n    let tableContainer\n\n    /**\n     * Perform an health check on the passed table\n     * @returns void\n     */\n    healthCheck(table)\n\n    /**\n     * Cache container width after health check passed\n     */\n    let oldTableContainerWidth = tableContainer.clientWidth\n\n    /**\n     * This is store for currently hidden cells\n     * @type Array\n     */\n    let hiddenCells = []\n\n    /**\n     * Constant index of cells generated from target row\n     * @type Array\n     */\n    let constIndex = []\n\n    /**\n     * @type object\n     */\n    let state = { current: -1 }\n\n    /**\n     * Process the config options passed\n     * @returns void\n     */\n    processConfig()\n\n    /**\n     * Attach event listeners for control toggle\n     * @returns void\n     */\n    setToggleCell(table)\n\n    /**\n     * Resize event method\n     */\n    _this.watchResize = false\n\n    /**\n     * Resize event method\n     */\n    _this.nativeResize = false\n\n    /**\n     * observer event method\n     */\n    _this.observer = false\n\n    /**\n     * Renders the table for the first instance\n     * @returns void\n     */\n    render()\n\n    /**\n     * Starts a mutation observer\n     * @returns void\n     */\n    watchMutation(table)\n\n    /**\n     * Set rendering target row\n     * @param {HTMLTableElement} table \n     */\n    function setTargetRow(table) {\n        targetRow = table.tHead.rows[0]\n    }\n\n    /**\n     * set the wrapper for podtable\n     */\n    function setWrapper() {\n        tableContainer = document.createElement('div')\n        tableContainer.setAttribute('id', 'podtable-container')\n        table.parentNode.insertBefore(tableContainer, table)\n        tableContainer.appendChild(table)\n    }\n\n    /**\n     * Perform health check and if it fail will throw an error\n     * @param {HTMLTableElement} table \n     */\n    function healthCheck(table) {\n        if (!(table instanceof HTMLTableElement) || table == null || table.tHead == null) {\n            throw new Error('Invalid HTMLTableElement')\n        }\n\n        if (table.tHead.rows.length <= 0 || table.tHead.rows[0].cells.length < 0) {\n            throw new Error('Invalid tHead HTMLTableRowElement')\n        }\n\n        setTargetRow(table)\n        setWrapper()\n    }\n\n    /**\n     * Sets the control cells CSS clasess\n     * @param {String} tableEl \n     */\n    function setToggleCell(table) {\n        for (let row of table.rows) {\n            if (row.parentElement.tagName.toUpperCase() == 'TBODY') {\n                if (!row.hasAttribute('data-ptr-ignore')) {\n                    row.lastElementChild.classList.add('toggle')\n                }\n            }\n            \n            if (row.parentElement.tagName.toUpperCase() == 'THEAD') {\n                row.lastElementChild.classList.add('main-toggle')\n            }\n        }\n    }\n\n    /**\n     * Set cell hidden priority from the right\n     * Set indexes of cells to keep\n     */\n    function processConfig() {\n        let tempConst = []\n\n        for (let ci = 0; ci < targetRow.cells.length; ci++) {\n            tempConst.push(ci)\n        }\n\n        if (Array.isArray(options.priority) && options.priority.length > 0) {\n            constIndex = Array.from(new Set(options.priority.concat(tempConst.reverse())))\n        } else {\n            constIndex = tempConst.reverse()\n        }\n\n        if (!Array.isArray(options.keepCell)) {\n            throw TypeError('keepCell is not an array')\n        } else {\n            options.keepCell.push(0, tempConst.length - 1)\n        }\n    }\n\n    /**\n     * Create HTMLTableRowElement & append cell column data\n     * @param {HTMLCollection} cells \n     * @returns HTMLTableRowElement\n     */\n    function childRow(cells) {\n        let tr = document.createElement('tr')\n        let gridTD = document.createElement('td')\n        let gridRow = document.createElement('div')\n\n        gridTD.colSpan = constIndex.length\n        gridRow.classList.add('child-grid-row')\n        tr.classList.add('child')\n\n        for (let i = 0; i < cells.length; i++) {\n            gridRow.append(cells[i])\n        }\n\n        gridTD.append(gridRow)\n        tr.append(gridTD)\n\n        return tr\n    }\n\n    /**\n     * Create HTMLElement to append to child row\n     * @param {HTMLTableCellElement} el\n     * @returns HTMLElement\n     */\n    function gridCol(el) {\n        let gridCol = document.createElement('div')\n        gridCol.classList.add('child-grid-col')\n\n        let dataColName = document.createElement('div')\n        let dataColDesc = document.createElement('div')\n        dataColName.innerHTML = table.tHead.rows[0].cells[el.cellIndex].innerHTML\n        dataColDesc.innerHTML = el.innerHTML\n\n        gridCol.append(dataColName)\n        gridCol.append(dataColDesc)\n\n        return gridCol\n    }\n\n    /**\n     * Toggle single child row and calculate hidden element for the row \n     * @param {event} e\n     */\n    function toggle(e) {\n        if (hiddenCells.length <= 0) { return }\n\n        let parent = e.currentTarget.parentElement\n\n        if (parent.classList.contains('has-child')) {\n            parent.classList.remove('has-child')\n            parent.nextElementSibling.remove()\n        } else {\n            parent.classList.add('has-child')\n            let isHidden = []\n            for (let i = 0; i < parent.cells.length; i++) {\n                if (parent.cells[i].classList.contains('hidden')) {\n                    isHidden.push(gridCol(parent.cells[i]))\n                }\n            }\n\n            parent.parentNode.insertBefore(childRow(isHidden), parent.nextSibling)\n        }\n    }\n\n    /**\n     * Handles toggle all child rows event by checking which rows \n     * has child to close and which rows has no child to open\n     * @param {event} e\n     */\n    function toggleAll(e) {\n        if (hiddenCells.length <= 0) { return }\n\n        let toggleEls = document.querySelectorAll('.toggle')\n        let toggler = e.currentTarget\n\n        if (toggler.classList.contains('expanded')) {\n            for (let i = 0; i < toggleEls.length; i++) {\n                let togsParent = toggleEls[i].parentElement\n                if (togsParent.classList.contains('has-child')) {\n                    toggleEls[i].click()\n                }\n            }\n\n            toggler.classList.remove('expanded')\n        } else {\n            for (let i = 0; i < toggleEls.length; i++) {\n                let togsParent = toggleEls[i].parentElement\n                if (!togsParent.classList.contains('has-child')) {\n                    toggleEls[i].click()\n                }\n            }\n\n            toggler.classList.add('expanded')\n        }\n    }\n\n    /**\n     * Adds click Event listener to rows with css class of \n     * toggle and main-toggle so as to toggle child rows\n     * @return void\n     */\n    function addToggleListener() {\n        let togElements = document.querySelectorAll('.toggle')\n        for (let i = 0; i < togElements.length; i++) {\n            togElements[i].addEventListener('click', toggle)\n        }\n\n        let mainToggle = document.querySelector('.main-toggle')\n        mainToggle.addEventListener('click', toggleAll)\n    }\n\n    /**\n     * Remove control toggle listener on rows\n     * @return object\n     */\n    function removeToggleListener() {\n        let togElements = document.querySelectorAll('.toggle')\n        for (let i = 0; i < togElements.length; i++) {\n            togElements[i].removeEventListener('click', toggle)\n        }\n\n        let mainToggle = document.querySelector('.main-toggle')\n        mainToggle.removeEventListener('click', toggleAll)\n    }\n\n    /**\n     * Check if there are hidden elements ands determine when to show\n     * child row toggle button and also clean up unused css class.\n     */\n    function doTogglerScreen() {\n        if (hiddenCells.length > 0) {\n            table.classList.add('show-toggle')\n        } else {\n            document.querySelectorAll('.has-child').forEach(el => {\n                el.classList.remove('has-child')\n            })\n\n            table.classList.remove('show-toggle')\n            table.tHead.rows[0].cells[table.tHead.rows[0].cells.length - 1].classList.remove('expanded')\n        }\n    }\n\n    /**\n     * Check for open child rows to enable reactivity as window resizes\n     * then apply changes, item are remove and added every time window resize\n     * and its like this so as to get an updated data from the cells\n     * child row are redrawn on each control toggle.\n     */\n    function childRowListener() {\n        let childRows = document.querySelectorAll('tr.child')\n\n        if (childRows.length > 0) {\n            let parentRows = []\n\n            for (let row of childRows) {\n                parentRows.push(row.previousElementSibling)\n            }\n\n            // Iterate from parents elements down to child elements\n            for (let p = 0; p < parentRows.length; p++) {\n                let isHidden = []\n\n                for (let cell of parentRows[p].cells) {\n                    if (cell.classList.contains('hidden')) {\n                        isHidden.push(gridCol(cell))\n                    }\n                }\n\n                // we will remove the existing child row and put another one with new data\n                // we also check if the hidden cells length > 0 before inserting a new child row\n                // so as to avoid empty child rows and orphaned child rows\n                parentRows[p].nextElementSibling.remove()\n\n                if (hiddenCells.length > 0) {\n                    parentRows[p].after(childRow(isHidden))\n                }\n\n                doTogglerScreen()\n            }\n        }\n    }\n\n    /**\n     * Hide cells that falls into maximum squishitude\n     * Dispatch event for the current hidden cells index\n     * @param {Number} index \n     */\n    function hideMain(index, pt = table) {\n        hiddenCells.push(index)\n\n        for (let row of pt.rows) {\n            if (!row.classList.contains('child') && !row.hasAttribute('data-ptr-ignore')) {\n                row.cells[index].classList.add('hidden')\n            }\n        }\n\n        eventDispatch(index)\n    }\n\n    /**\n     * Here we remove the hidden class and flush the hidden cells \n     * array so as to restart procedure for the current viewport.\n     */\n    function flush() {\n        for (let i = 0; i < hiddenCells.length; i++) {\n            for (let row of table.rows) {\n                if (!row.classList.contains('child') && !row.hasAttribute('data-ptr-ignore')) {\n                    row.cells[hiddenCells[i]].classList.remove('hidden')\n                }\n            }\n        }\n\n        hiddenCells = []\n    }\n\n    /**\n     * Recalculate Cells thats needs to be hidden after flushing\n     */\n    function recalc() {\n        flush()\n\n        for (let i = 0; i < constIndex.length; i++) {\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\n                if (!hiddenCells.includes(constIndex[i])) {\n                    if (!options.keepCell.includes(constIndex[i])) {\n                        hideMain(constIndex[i])\n                        childRowListener()\n                    }\n                }\n            }\n        }\n\n        doTogglerScreen()\n    }\n\n    /**\n     * This method recalculate which cells to hide or show and dispatch\n     * event with negative index to indicate there are no hiddenCells\n     */\n    function resize() {\n        recalc()\n\n        if (hiddenCells.length <= 0) {\n            eventDispatch(-1)\n            childRowListener()\n        }\n    }\n\n\n    /**\n     * On mounted calculate cells which  can fit into the current\n     * maximum squishitude: apply visibility, attach listeners.\n     */\n    function mount() {\n        hiddenCells = []\n        let ilength = constIndex.length\n\n        for (let i = 0; i < ilength; i++) {\n\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\n                if (!hiddenCells.includes(constIndex[i])) {\n                    if (!options.keepCell.includes(constIndex[i])) {\n                        hideMain(constIndex[i])\n                    }\n                }\n            }\n        }\n        doTogglerScreen()\n    }\n\n    /**\n     * This is the resize counterpart for window resize event\n     * or element watcher event\n     * @see resize\n     */\n    function observeResize() {\n        recalc()\n        if (hiddenCells.length <= 0) {\n            eventDispatch(-1)\n            childRowListener()\n        }\n    }\n\n    /**\n     * Handles resize listener\n     * @returns boolean|ResizeObserver\n     */\n    function observed() {\n        try {\n            _this.nativeResize = new ResizeObserver((entries) => {\n                if (entries[0].target.clientWidth !== oldTableContainerWidth) {\n                    observeResize()\n                }\n\n                oldTableContainerWidth = entries[0].target.clientWidth\n            })\n\n            _this.nativeResize.observe(tableContainer)\n            return true\n        } catch (err) {\n            return false\n        }\n    }\n\n    /**\n     * Starts an observer at podtable instance and \n     * attach necessary listeners\n     */\n    function render() {\n        mount()\n        addToggleListener()\n\n        if (!observed()) {\n            try {\n                _this.watchResize = watch(tableContainer, resize)\n                _this.watchResize.start()\n            } catch (err) {\n                window.addEventListener('resize', resize) \n            }\n        }\n    }\n\n    /**\n     * Revert all events made to the DOM\n     */\n    function destroy() {\n        window.removeEventListener('resize', resize)\n        flush()\n\n        detachRows(table, tableContainer, _this)\n        removeToggleListener()\n    }\n\n    /**\n     * Revert any alteration to the table in the DOM\n     * and detach events\n     * @returns void\n     */\n    state.destroy = () => destroy()\n\n    /**\n     * Handles childList mutations by re-attaching attributes, \n     * events and dispatching events\n     * @param {HTMLTableElement} table \n     */\n    function watchMutation(table) {\n        function resetRow(node) {\n            if (!node.hasAttribute('data-ptr-ignore')) {\n                node.lastElementChild.classList.add('toggle')\n                node.lastElementChild.addEventListener('click', (e) => toggle(e))\n            }\n        }\n\n        const callback = (mutations) => {\n          for (const mutation of mutations) {\n            if (mutation.type == 'childList' && mutation.addedNodes.length == 1) {\n              if (mutation.addedNodes[0].tagName.toUpperCase() == 'TBODY') {\n                for (let node of mutation.addedNodes[0].children) {\n                  resetRow(node);\n                  shouldPing();\n                }\n              }\n\n              if (\n                mutation.addedNodes[0].tagName.toUpperCase() == 'TR' &&\n                !mutation.addedNodes[0].classList.contains('child')\n              ) {\n                resetRow(mutation.addedNodes[0]);\n                shouldPing();\n              }\n            } else if (mutation.type == 'childList' && mutation.removedNodes.length == 1) {\n              if (\n                mutation.removedNodes[0].tagName.toUpperCase() == 'TR' &&\n                !mutation.removedNodes[0].classList.contains('child') &&\n                mutation.removedNodes[0].classList.contains('has-child')\n              ) {\n                mutation.nextSibling.remove();\n              }\n            } else if (mutation.type == 'characterData') {\n              console.log(mutation.target);\n            }\n          }\n\n          setTargetRow(table);\n          flush();\n          mount();\n        };\n\n        let observable = options.rowGroup ? table : table.tBodies[0];\n        _this.observer = new MutationObserver(callback);\n        _this.observer.observe(observable, { childList: true, characterData: true, subtree: true });\n    }\n\n    /**\n     * Dispatch event for the current hidden cell index\n     * @param {Number} index \n     */\n    function eventDispatch(index) {\n        state.current = index\n\n        if (options.method) { shouldPing() }\n    }\n\n    /**\n     * Dispatchs event\n     */\n    function shouldPing() {\n        if (options.method) {\n            try {\n                options.method(state)\n            } catch (err) {\n                console.error(err)\n            }\n        }\n    }\n\n    return state \n}\n\nexport default Podtable","export function watch(element, fn) {\n    let _this = {}\n    let obj = document.createElement('object')\n\n    /**\n     * Event listener to the docs object\n     */\n    function resizeEvent () {\n        this.contentDocument.defaultView.addEventListener('resize', fn)\n    }\n\n    /**\n     * Attach event listener to object\n     */\n    _this.start = () => {\n        obj.classList.add('pt-object')\n        obj.type = 'text/html'\n        obj.data = 'about:blank'\n        obj.onload = resizeEvent\n        element.appendChild(obj)\n    }\n\n    /**\n     * dettach event listener and remove object\n     */\n    _this.stop = () => {\n        obj.contentDocument.defaultView.removeEventListener('resize', fn)\n        element.removeChild(obj)\n    }\n\n    return _this\n}\n\n/**\n * Returns the target table element\n * @param {String|HTMLTableElement} tableEl \n * @returns HTMLTableElement\n */\nexport function getTable(tableEl) {\n    if (typeof tableEl === 'string' || tableEl instanceof String) {\n        return document.querySelector(tableEl)\n    } else {\n        return tableEl\n    }\n}\n\n/**\n * Detach child rows from the dom and remove classes\n * @param { HTMLTableElement }\n */\nexport function detachRows(table, container, _this) {\n    _this.observer.disconnect()\n\n    if (typeof _this.nativeResize !== undefined && _this.nativeResize !== false)\n        _this.nativeResize.disconnect()\n    \n    if (typeof _this.watchResize !== undefined && _this.watchResize !== false)\n        _this.watchResize.stop()\n\n    let parentRows = table.querySelectorAll('tr.has-child')\n\n    for (let row of parentRows) {\n        row.classList.remove('has-child')\n        if (row.nextElementSibling.classList.contains('child')) {\n            row.nextElementSibling.remove()\n        }\n    }\n\n    table.classList.remove('show-toggle')\n    container.replaceWith(...container.childNodes)\n}"],"names":["tableEl","config","targetRow","tableContainer","_this","options","Object","assign","keepCell","priority","method","rowGroup","table","String","document","querySelector","getTable","HTMLTableElement","tHead","Error","rows","length","cells","setTargetRow","setWrapper","healthCheck","oldTableContainerWidth","clientWidth","hiddenCells","constIndex","state","current","createElement","setAttribute","parentNode","insertBefore","appendChild","childRow","tr","gridTD","gridRow","colSpan","classList","add","i","append","gridCol","el","dataColName","dataColDesc","innerHTML","cellIndex","toggle","e","parent","currentTarget","parentElement","contains","remove","nextElementSibling","isHidden","push","nextSibling","toggleAll","toggleEls","querySelectorAll","toggler","click","doTogglerScreen","forEach","childRowListener","childRows","_step2","parentRows","_iterator2","_createForOfIteratorHelperLoose","done","value","previousElementSibling","p","_step3","_iterator3","cell","after","hideMain","index","pt","_step4","_iterator4","row","hasAttribute","eventDispatch","flush","_iterator5","_step5","recalc","includes","resize","mount","ilength","shouldPing","err","console","error","tempConst","ci","Array","isArray","from","Set","concat","reverse","TypeError","processConfig","_iterator","_step","tagName","toUpperCase","lastElementChild","setToggleCell","watchResize","nativeResize","observer","togElements","addEventListener","addToggleListener","ResizeObserver","entries","target","observe","observed","element","fn","obj","resizeEvent","this","contentDocument","defaultView","start","type","data","onload","stop","removeEventListener","removeChild","watch","window","render","resetRow","node","observable","tBodies","MutationObserver","mutations","_step6","_iterator6","mutation","addedNodes","_step7","_iterator7","children","removedNodes","log","childList","characterData","subtree","watchMutation","destroy","container","disconnect","undefined","replaceWith","apply","childNodes","detachRows","removeToggleListener"],"mappings":"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"}